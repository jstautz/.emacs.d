#+TITLE: Jeff's Emacs config
#+AUTHOR: Jeff Stautz
#+EMAIL: jeff@jeffstautz.com
#+LANGUAGE:  en
#+OPTIONS: toc:nil num:nil ^:nil H:4
#+PROPERTY: header-args :tangle "lisp/emacs-init.el"

#+begin_quote
People talk about getting used to a new editor, but over time, it is precisely the opposite that should happen --- the editor should get used to us.

--- [[http://blog.vivekhaldar.com/post/31970017734/new-frontiers-in-text-editing][Vivek Hadlar]]
#+end_quote

#+TOC: headlines 2

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

** What is this?
:PROPERTIES:
:CUSTOM_ID: what_is_this
:END:

It's a [[http://en.wikipedia.org/wiki/Literate_programming][literate programming]] version of my Emacs config files.

My current setup borrows liberally from Emacs users far smarter than I am, including: 
- [[http://doc.norang.ca/org-mode.html][Bernt Hansen]] 
- [[https://github.com/eschulte/emacs24-starter-kit][Eric Schulte]]
- [[https://github.com/magnars/.emacs.d][Magnar Sveen]]
- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]]
- [[https://github.com/technomancy/dotfiles][Phil Hagelberg]]
- [[https://github.com/bodil/emacs.d][Bodil Stokke]]
- [[http://www.masteringemacs.org/][Mickey Petersen]]
- And a ton of others. 

Props and praises are scattered throughout my config in places where I can remember who I stole something from.

** What's literate programming?
:PROPERTIES:
:CUSTOM_ID: what_is_literate
:END: 

Short answer: instead of writing separate documentation, the documentation /contains/ the program. The code itself is secondary to the explanation about how it works.

Or as Knuth puts it:

#+begin_quote 
Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on /explaining to humans/ what we want the computer to do.

--- Donald E. Knuth, Literate Programming, 1984
#+end_quote

The document you're reading now is an [[http://org-mode.org][org-mode]] text file that contains both code *and* documentation. 

On startup, emacs pulls out ("tangles") the code snippets in this file and uses them to configure the editor.

** Why would you use literate programming for your Emacs config?
:PROPERTIES:
:CUSTOM_ID: why_literate
:END:

It's an experiment. We'll see how well it works out.

I've been inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's literate emacs config]], as well as by [[http://doc.norang.ca/org-mode.html][Bernt Hansen's amazingly thorough and detailed documentation of his org-mode setup]].

Using a literate programming approach has a number of advantages that appeal to me:

1. *Better organization of my .emacs lisp files*
   - My elisp code snippets are embedded within the foldable goodness of org-mode's outline structure.
   - My configuration is better organized and easier to understand.

2. *I'm better able to follow my own thought processes.*
   - Explanations take priority, code is secondary.
   - When I revisit code I wrote ten years ago, I have a hope of understanding /what the hell I was thinking./

3. *Sharing my setup is easier*
   - I have one file that generates nice-looking documentation and the code itself.
   - Detailed explanations of my setup mean it's easier for others to understand it and benefit from it.

* Structure --- how this works 
:PROPERTIES:
:CUSTOM_ID: structure
:END:

Before we get too deep into my settings, I should explain a little about how all this works.

** init.el
:PROPERTIES:
:CUSTOM_ID: init.el
:END:

My init.el file is only a half-dozen lines of elisp. Its only real job is to bootstrap the rest of my config by loading it via org-babel.

It looks like this:

#+BEGIN_EXAMPLE emacs-lisp
(package-initialize)

;; Assume the current directory is our dot-emacs directory
(setq dotemacs-dir (file-name-directory (or load-file-name (buffer-file-name))))

;; If emacs-init.el is *newer* than emacs-init.org, then load the *.el file directly.
;; Otherwise, tangle the *.org file and load.
(if (> (string-to-int (shell-command-to-string "stat -f \"%m\" ~/.emacs.d/lisp/emacs-init.el"))
       (string-to-int (shell-command-to-string "stat -f \"%m\" ~/.emacs.d/emacs-init.org")))
      (load-file (expand-file-name "lisp/emacs-init.elc" dotemacs-dir))
  (org-babel-load-file (expand-file-name "emacs-init.org" dotemacs-dir) t))
#+END_EXAMPLE

That's it.

The important part is that last s-expression: 

#+BEGIN_EXAMPLE emacs-lisp
(org-babel-load-file (expand-file-name "emacs-init.org" dotemacs-dir) t)
#+END_EXAMPLE

This line calls org-babel to extract ("tangle") the code blocks from the =emacs-init.org= file into a file called =emacs-init.el=, then compile it. It then tells Emacs to load all the configurations in that compiled .elc file.

[[http://orgmode.org/worg/org-contrib/babel/][Org-babel is Merlin-level wizardry.]] Eric Schulte, Dan Davison, and everyone who's worked on it all deserve medals. 

Because tangling and loading my .org file takes a few seconds, I've wrapped this call to org-babel in an =if= statement that checks to see if any recent changes have been made to the org file. 

** emacs-init.org
:PROPERTIES:
:CUSTOM_ID: emacs-init.org
:END:

The =emacs-init.org= file is the meat of my emacs config. It's also the document you're reading right now.

When this document is tangled and loaded by org-babel, =emacs-init.el= is updated with the latest elisp extracted from code blocks in this file.

I try to treat the resulting =emacs-init.el= file like /compiled code/. I try not to look at it too often, except when debugging.

Any edits or changes, even if they're experimental, are made in the .org file instead of directly in the .el file. This way, I'm ensuring my documentation always stays up to date.

** Packages 
:PROPERTIES:
:CUSTOM_ID: packages
:END:

Back in the dark ages, I would find third-party elisp packages on the interwebs and install them manually. This got nasty pretty quickly.

Emacs 24 introduced a really nice package management system, =package.el=. I used it for a while on its own, then supplemented it with [[https://github.com/jwiegley/use-package][use-package]].

*** package.el
:PROPERTIES:
:CUSTOM_ID: package.el
:END:

Use =M-x package-list-packages= to browse packages on all source repos, then install/uninstall/update them from within Emacs.

Here's what it looks like:

[[file:img/list-packages.png]]

Before using the package manager, I want to add a few other sources (notably [[http://melpa.milkbox.net/#/][melpa]] and the org-mode source) to my package source list.
  
#+name: package-set-sources
#+BEGIN_SRC emacs-lisp
;; set package sources
(dolist (source '( ("gnu"   . "http://elpa.gnu.org/packages/")
                   ("elpa"  . "http://tromey.com/elpa/")
		         ("org"   . "http://orgmode.org/elpa/")
                   ("melpa" . "http://melpa.milkbox.net/packages/")))
  (add-to-list 'package-archives source t))
(package-initialize)

#+END_SRC

*** use-package
:PROPERTIES:
:CUSTOM_ID: use-package
:END:

[[https://github.com/jwiegley/use-package][John Wiegley's use-package]] provides some really nice macros for autoloading and configuring packages. It handles a lot of things for me out of the box, including:

- Grabbing any missing packages from the internet
- Initializing and autoloading packages
- Nicely isolating package-specific configs
- Setting keybindings in a very readable way
- Deferring configuration elisp until after a package actually gets used
- And more!

First, let's grab =use-package= from elpa if it's not already installed. 

#+name: package-install-use-package
#+BEGIN_SRC emacs-lisp
;; install use-package, which my setup relies on
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

#+END_SRC

Now let's load =use-package=, and then set it up so that any package we try to load is treated as if we've specified the =:ensure= keyword --- meaning that if the package isn't present on the system, we'll download it from the interwebs.

#+name: package-use-package
#+BEGIN_SRC emacs-lisp
(require 'use-package)
(setq use-package-always-ensure t)

#+END_SRC

*** /elpa directory

When I install any packages (either via =use-package= or manually with package.el), they're saved in my =~/.emacs.d/elpa/= directory.

In the past, I kept this directory in my .gitignore, so that I wasn't saving a ton of third party packages in my .emacs github repo. 

In reality, this caused more problems for me than it was worth. 

Whenever I wanted to use Emacs on a new machine, my config would pull down new copies of packages off the internet --- which is great! --- BUT then I'd spend the next three days trying to sort out dependency issues and breaking changes with the latest versions of several packages.

I found that I'd much rather check *everything* in, so that I've got a "known working state" I can check out at any time.

* How I Use Emacs
:PROPERTIES:
:CUSTOM_ID: how-i-use-emacs
:END:

#+begin_quote
This is my rifle. There are many like it, but this one is mine.

--- Major General William H. Rupertus, "The Rifleman's Creed," 1942
#+end_quote

Before we get into the actual configuration, it might help to understand some things I do in Emacs.

My use of Emacs is by no means typical, and my configuration reflects this fact.

** Org-mode

[[file:img/org.png]]

I spend 90% of my time in Emacs inside [[http://orgmode.org/][org-mode]]. 

I've been using it for several years for taking notes, planning, writing, and tracking my to-do lists. It's a brilliant piece of software that's totally changed how I organize my digital life. 

I've got a whole separate section of my Emacs config dedicated to the ins and outs of my org-mode configuration. It's gnarly. It's complicated. But it /works/ for me. 

** Writing

For the last 12+ years, I've done most of my fiction writing, journaling, editing, and revising in plain text within Emacs.

Sometimes I work in [[https://daringfireball.net/projects/markdown/][Markdown syntax]] and view the formatted version of my documents in [[http://markedapp.com/][Marked.app]].

Other times I write using minimal [[http://www.latex-project.org/][LaTeX markup]], which I then run through a perl script to add full LaTeX document headers for exporting.

More recently, I've started using the =org-export= features of org-mode in order to create LaTeX and PDF docs.

Details of how I use Emacs for fiction writing are documented later in this file. 

** Programming

Unlike many (most?) Emacs users, I don't develop software professionally anymore.

I've done a bunch of software development work in the past, and I enjoy messing around in code occasionally. I dabble. I pretend like I know what I'm doing. But I'm nowhere near professional.

[[http://hootsuite.com/careers/][I work with a ton of talented engineers every day at Hootsuite]] and they constantly inspire me to learn more, try more, and hack more. 

There are a couple of languages I work with regularly:

- I use Emacs lisp quite a bit (of course)
- I occasionally mangle some Python
- I play around with Javascript
- I'm learning Go

My Emacs settings for software development should be taken with several grains of salt --- these parts of my config aren't very mature and I'm probably doing everything wrong.

** Manipulating files and text of all kinds

Macros, mutli-line editing, directory editing, remote editing over SSH... Emacs is my Swiss Army knife for text and file transformations. 

There are large chunks of my config that deal with sharpening various blades of said Swiss Army knife.

* Prerequisites
:PROPERTIES:
:noweb-ref: Prerequisites and setup --- load basic support libraries, set some useful variables
:CUSTOM_ID: setup
:END:  

Now let's get into the config itself.

This first section contains some libraries and basic settings that the rest of my configuration depends on.

** First, let's load Common Lisp libraries

This is generally a good idea. There's a lot of good stuff in the CL package that many other packages need.

#+name: setup-require-cl :comments both
#+BEGIN_SRC emacs-lisp
(use-package cl)

#+END_SRC

** Then set our path appropriately.

This is a gross hack to grab the $PATH environment variable from my ~/.bashrc and use it. This way my path is consistent between Emacs.app and my shell elsewhere.

#+name: setup-path :comments both
#+BEGIN_SRC emacs-lisp
;; ensure OS X keeps my path consistent in Emacs
(let ((jcs:shell-path (shell-command-to-string ". ~/.bashrc; echo -n $PATH")))
  (setenv "PATH" jcs:shell-path)
  (setq exec-path (split-string jcs:shell-path ":")))

#+END_SRC

Yeah, you read that elisp right. Icky, but it works. This workaround's required because of the way OS X launches apps. The only other solution would be to mess around with =launchctl=, and I really don't want to do that right now.
 
** Set a few variables for directories

Define our home directory, dot emacs directory (where the config lives), emacs binary directory (where Emacs.app lives), and info file directory.

I use these =*-dir= variables all over the place in my config.

Some of these are obviously going to be different in your setup, so you'll want to change them accordingly.

#+name: setup-dirs :comments both
#+BEGIN_SRC emacs-lisp
;; fantastic directories and where to find them
  (defvar home-dir     "/Users/jeff.stautz/")
  (defvar dotemacs-dir (concat home-dir ".emacs.d/"))
  (defvar lisp-dir     (concat dotemacs-dir "lisp/"))
  (defvar emacs-dir    "/Applications/Emacs.app/Contents/")
  (defvar emacs-bin    (concat emacs-dir "MacOS/Emacs"))
  (defvar info-dir     (concat emacs-dir "Resources/info/"))
#+END_SRC

** Add lisp directory to load-path

Our load-path defines where Emacs should look for packages, functions, variables, etc. 

We should add the ~/.emacs.d/lisp/ directory to this list.

#+name: setup-load-path
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path lisp-dir)

#+END_SRC
** Tell 'customize' where to save changes

I don't generally use =M-x customize= --- I prefer to =setq= these variables in my init files manually --- but sometimes I'll fiddle with settings in customize to try things out.

When I do so, I'd like customize to save things in a separate =emacs-custom= file. I treat this file as temporary storage. If I like the changes, I'll pull them out of this file and place them in the appropriate places in my config.

#+name: setup-custom-file
#+BEGIN_SRC emacs-lisp
;; Arr, here be my custom file
(setq custom-file (concat lisp-dir "custom.el"))

#+END_SRC

** Decrypt secrets.el.gpg

My passwords, private URLs, and personal info are encrypted and stored in the secrets.el.gpg file. Emacs decrypts this using the keys in my .gnupg keyring.

I do this *before* I begin loading packages, so that package configs can access variables stored in the secrets file.

#+name: setup-decrypt-secrets-function
#+BEGIN_SRC emacs-lisp
(defun jcs:decrypt-secrets ()
  (interactive)
  (require 'secrets))

#+END_SRC

* Install and configure packages

#+begin_quote
Brown paper packages tied up with strings
These are a few of my favorite things

--- Austrian Mary Poppins
#+end_quote

I've settled on a relatively small set of packages for my current Emacs config. 

I'll probably add to this over time, because I just can't help myself.

** Ace-jump mode

It's [[https://www.youtube.com/watch?v=UZkpmegySnc][hard to describe ace-jump-mode unless you see it in action]]. 

Let's say I want to move to the "m" in the word "mentioned" in the line above. I just activate ace-jump-mode (I've bound it to =C-.=), then type "m". At this point, emacs highlights all matches in the buffer, like this:

[[file:img/ace-jump.png]]

Notice each word beginning with "m" now starts with a red letter. I type "b" to jump to the word "mentioned."

#+name: ace-jump
#+BEGIN_SRC emacs-lisp
;; jump around, House of Pain style
(use-package ace-jump-mode
             :bind ("C-." . ace-jump-mode))

#+END_SRC

This is a super-fast way to quickly move your cursor around in the buffer -- handy whether you're working in a text file or with code.

** Browse kill ring

=C-y= yanks from the top of the kill ring, and hitting =C-y M-y, M-y, M-y= repeatedly will cycle through previous kills. But what if you want to browse through the whole kill ring and find that text you killed a few hours ago?

Hitting =M-y= activates browse-kill-ring and let you dig through your kill history, select an item, and yank it into the buffer.

#+name: browse-kill-ring
#+BEGIN_SRC emacs-lisp
;; show me the graveyard with M-y
(use-package browse-kill-ring
             :defer t
             :init
             (progn
               (autoload 'browse-kill-ring-default-keybindings "browse-kill-ring")
               (browse-kill-ring-default-keybindings)))

#+END_SRC

** Diminish mode

I like keeping my mode-line clean.

Diminish is a package that lets you replace the default major/minor mode indicators in the mode-line with shorter abbreviations (or hide them altogether).

#+name: diminish
#+BEGIN_SRC emacs-lisp
;; use fewer letters
(use-package diminish)

#+END_SRC

Even better, use-package supports diminsh options as part of the declaration when loading packages.

Diminish also features [[http://www.eskimo.com/~seldon/diminish.el][some of the best code comments in the universe]].

** ido & smex

[[file:img/ido.png]]

[[http://emacswiki.org/emacs/InteractivelyDoThings][ido (short for "*interactively do* things")]] is a fantastic package, and one of the first things I recommend a new Emacs user set up. It's actually a part of Emacs as of v22, but requires a bit of configuration to make it *really* powerful.

[[https://www.youtube.com/watch?v=lsgPNVIMkIE][ido provides autocomplete features for files and buffers]], and it supports things like fuzzy matching and "virtual buffers" for revising recently-closed buffers.

*** ido settings

Let's turn on ido and configure it, shall we? It's got a lot of bells and whistles.

The first things we want to do are to enable flex matching, turn ido on everywhere, ignore case when completing, and set up max prospects and faces. 

#+name: ido-settings-1
#+BEGIN_SRC emacs-lisp
;; unlock the magic
(ido-mode t)
(setq ido-enable-flex-matching t
      ido-everywhere t
      completion-ignore-case t           
      read-file-name-completion-ignore-case t
      ido-max-prospects 20
      ido-use-faces t)
#+END_SRC

Next, I want to turn off some of the tramp-related and ftp-related options --- these caused stalls for me in the past.

#+name: ido-settings-2
#+BEGIN_SRC emacs-lisp
(setq ido-record-ftp-work-directories nil
      ido-enable-tramp-completion nil
      ido-is-tramp-root nil)
#+END_SRC

Now let's add some magic: we'll turn on recentf-mode and allow ido to list my recently-closed buffers as possible matches. This is so damn handy.

#+name: ido-settings-3
#+BEGIN_SRC emacs-lisp
(recentf-mode t)
(setq ido-use-virtual-buffers t)
#+END_SRC

Let's fix a couple of navigation-related annoyances as well. By default, if no matches are found, ido will kick off a search for the file you might have meant. I found this annoying, so I disable it.

I also like being able to navigate into a directory and hit =.= to get dropped into dired in that directory.

And I want to invoke ido when my cursor is on a filename in the buffer text and have that file suggested as a completion. 

#+name: ido-settings-4
#+BEGIN_SRC emacs-lisp
(setq ido-auto-merge-work-directories-length -1
      ido-show-dot-for-dired t
      ido-use-filename-at-point 'guess)
#+END_SRC

I'm not sure why this is disabled by default, but let's enable it:

#+name: ido-settings-5
#+BEGIN_SRC emacs-lisp
(put 'ido-exit-minibuffer 'disabled nil)

#+END_SRC

*** ido-completing-read+

[[https://github.com/DarwinAwardWinner/ido-completing-read-plus][ido-completing-read+]] is an additional package that enables ido in even more places. Let's fire it up:

#+name:ido-ubiquitous
#+BEGIN_SRC emacs-lisp
;; use ido everywhere
(use-package ido-completing-read+)
(ido-ubiquitous-mode 1)

#+END_SRC

With this enabled, you'll be able to do things like hit =C-h f= (describe-function) and see a nice list of possible completions --- it'll even default suggest the function your cursor's sitting on.

*** ido-vertical

By default, ido lists possible completions horizontally, wrapping them if there are more completions than fit on the line. 

I prefer having completion candidates listed vertically and left-aligned --- they're much easier to scan that way.

We'll use [[https://github.com/gempesaw/ido-vertical-mode.el][the ido-vertical-mode package]] to set this up, and define keys for navigating up and down between candidates in the list.

#+name:ido-vertical
#+BEGIN_SRC emacs-lisp
;; stack my completions
(use-package ido-vertical-mode
             :init
             (progn (ido-vertical-mode 1)
                    (setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right)))

#+END_SRC

*** smex

[[file:img/smex.png]]

[[https://github.com/nonsequitur/smex][The smex package]] gives you all the autocompletion and fuzzy-matching goodness of ido, but for =M-x=, the infamous =execute-extended-command= function. 

Instead of hunting and scraping to find the function I'm looking for, I use smex + fuzzy matching and feel like an Emacs god.

#+name: smex-settings
#+BEGIN_SRC emacs-lisp
;;smexy smex
(use-package smex)
(global-set-key (kbd "M-x") 'smex)
(global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+END_SRC

I can get back to my original =M-x= functionality if I need it by using =C-c C-c M-x=.

#+name: smex-settings-old-mx
#+BEGIN_SRC emacs-lisp
;; This is your old M-x.
(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)

#+END_SRC
** Guide Key

#+ATTR_HTML: :width 600
[[file:img/guide-key-example.png]]

Guide-key lets you set up useful completion hints for certain key combinations. 

For example, I'm always forgetting certain org-mode shortcuts, so I've set up guide-key so that when I'm working in org, I can type =C-c= and wait a second to see a menu of all possible commands that start with =C-c=. 

It's especially useful when learning a new mode or new set of commands.

I can and should probably tweak this a little more and add additional key sequences to it, but for now this setup meets most of my needs.

#+name: guide-key
#+BEGIN_SRC emacs-lisp
;; gimme some hints
(use-package guide-key)
(defun guide-key/jcs-hook-function-for-org-mode ()
  (guide-key/add-local-guide-key-sequence "C-c")
  (guide-key/add-local-guide-key-sequence "C-c C-x"))
(add-hook 'org-mode-hook 'guide-key/jcs-hook-function-for-org-mode)
(setq guide-key/idle-delay 1)
(setq guide-key/popup-window-position 'bottom)
(guide-key-mode 1)
(diminish 'guide-key-mode)

#+END_SRC

** Popwin

[[https://github.com/m2ym/popwin-el][Popwin]] is installed as a dependency of guide-key, and it makes certain kinds of "pop-up" windows within your frame act slightly differently from regular windows --- you're able to dismiss them quickly by typing =0=, and provides some other useful features.

#+name: popwin
#+BEGIN_SRC emacs-lisp
;; put those hints in a nice pop-up window
(use-package popwin)
(defun popwin-bkr:update-window-reference ()
  (popwin:update-window-reference 'browse-kill-ring-original-window :safe t))
(add-hook 'popwin:after-popup-hook 'popwin-bkr:update-window-reference)
(push "*Kill Ring*" popwin:special-display-config)
(popwin-mode 1)

#+END_SRC
** Magit

[[https://magit.vc/][Magit is git made magical.]] 

It wraps git commands in a spiffy interface that's legitimately enjoyable to use. Which is good, because I use it pretty much every day.

#+ATTR_HTML: :width 600
[[file:img/magit.png]]

I don't use many customized setup options for magit yet. I may in the future.

#+name: magit
#+BEGIN_SRC emacs-lisp
;; git on up
(use-package magit)
(setq magit-push-always-verify nil)

#+END_SRC

** Markdown

Most of the time, I'm writing things (fiction or non-fiction) in org-mode. The rare times when I'm not, I'm using straight-up Markdown.

#+name: writing-markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
           :mode "\\.\\(md\\|mdown\\|markdown\\)\\'")

#+END_SRC

* General Editor Settings
** Interface tweaks

I know, I know. Emacs doesn't have much of an interface to begin with. 

Even so, there are a couple of changes I like to make in order to make things a little cleaner.

*** Remove distracting UI elements

Emacs comes with a fat ugly toolbar turned on by default. Turning it off is one of the first things I do.

#+name: UI-toolbar
#+BEGIN_SRC emacs-lisp
;; Get rid of all that chrome and fuss
(tool-bar-mode -1)
#+END_SRC

I don't really use the side fringe at all, so I set it to blend in with my background face. ("face" in Emacs basically means "text style.")

#+name: UI-fringe
#+BEGIN_SRC emacs-lisp
(set-face-background 'fringe (face-background 'default))
(set-face-foreground 'fringe (face-background 'default))
#+END_SRC

Scroll bars are also pretty useless in the age of scroll wheels and trackpads, so I turn that off as well.

#+name: UI-fringe
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)

#+END_SRC

*** Hide welcome messages

We're all professionals, here. We know what we're doing. 

Let's ditch the splash screen, the startup message, and the default text on the scratch buffer:

#+name: UI-splash
#+BEGIN_SRC emacs-lisp
;; Don't talk to me
(setq inhibit-splash-screen 1)               
(setq initial-scratch-message "")
(setq inhibit-startup-message t)
#+END_SRC

*** Kill some UI annoyances

I hate the audible alert bell.

Let's set the ring-bell function to an empty function instead of the deafult (which is named, appropriately, =ding=).

#+name: UI-bells
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function (lambda ()))
#+END_SRC

Another obnoxious default to change: the requirement that you actually type the letters "y" "e" and "s" at a yes/no prompt. 

This s-exp lets you just type "y" or "n" to answer these prompts.

#+name: UI-yorn
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)

#+END_SRC

*** Confirm before quitting Emacs

I want to make sure I don't accidentally kill Emacs. Ever. 

I do this by changing two things:

1) Unset =C-x C-c= so I don't hit it accidentally, and
2) Prompt me to confirm that I actually want to quit.

If I want to quit Emacs (gasp!) I now need to do it *very* deliberately via =M-x save-buffers-kill-emacs= and then confirm.

Good thing I rarely quit Emacs.

#+name: UI-quit-emacs
#+BEGIN_SRC emacs-lisp
(global-unset-key "\C-x\C-c")
(setq confirm-kill-emacs 'y-or-n-p)

#+END_SRC
*** Themes

I want to trust all themes --- mostly so the mode-line setup below doesn't spit warnings at me on startup.

#+name: UI-trust-themes
#+BEGIN_SRC emacs-lisp
;; Trust me, I'm an interior decorator
(setq custom-safe-themes t)

#+END_SRC

*** Show line and column numbers

A basic feature of any decent text editor: show me what line number I'm on.

The column number display isn't as immediately useful, but it does come in handy.

#+name: UI-linum
#+BEGIN_SRC emacs-lisp
;; whose line is it, anyway?
(line-number-mode 1)                         
(column-number-mode 1)

#+END_SRC
** Backups & Trash settings

Emacs has some pretty useful features for auto-saving backups and integrating with OS X's Trash / filesystem.

*** Set backup directory

One problem with the default auto-save in Emacs is that it peppers your working directories with duplicates of your files, e.g. =#init.el#= =init.el~=.

Let's tell Emacs to put all these auto-saves and backups into a more useful location:

#+name: backup-dir
#+BEGIN_SRC emacs-lisp
;; Don't crap up my working directory with backups
(defvar backup-dir "~/.emacs.backup/")
(defvar autosave-dir "~/.emacs.autosave/")
(setq backup-directory-alist `((".*" . ,backup-dir)))
(setq auto-save-file-name-transforms `((".*" ,autosave-dir t)))

#+END_SRC

*** Backups + version control

You have to explicitly tell Emacs to keep saving backups of files if they're under version control. 

#+name: backup-vc
#+BEGIN_SRC emacs-lisp
;; I'm paranoid
(setq vc-make-backup-files t)

#+END_SRC

*** ~/.Trash integration

Instead of just blowing files away, I want all file-deletion events in Emacs to do a =mv file.txt ~/.Trash= rather than a simple =rm file.txt=. This is just another layer of protecting myself from myself.

#+name: backup-trashes
#+BEGIN_SRC emacs-lisp
;; Super paranoid
(setq delete-by-moving-to-trash t)
(setq trash-directory (concat "~/.Trash/"))

#+END_SRC

** Basic Keyboard settings
*** Unset some default keybindings

Let's unset a couple of keybindings:
- Read-only-toggle is bound by to =C-x C-q= by default. It's a useless command that I activate by accident way too often.
- I also fat-finger =F2= way too often. I may eventually use this key for something, but not yet.
- =C-x .= is bound to =set-fill-prefix=, which I rarely need.
- Command-tilde (=M-`=) is the OS X keybinding to flip between windows in an app. I use it a lot, and don't want to enter tmm-menubar if I hit it when I'm in Emacs.

#+name: keybindings-unsets
#+BEGIN_SRC emacs-lisp
;; Unset some defaults I don't like
(global-unset-key "\C-x\C-q")
(global-unset-key (kbd "<f2>"))     
(global-unset-key "\C-x.")
(global-unset-key "\M-`")

#+END_SRC

*** Save and Undo

Now let's set a couple of bindings based on my muscle memory:

- Rebind =M-s= to save-buffer --- I've been conditioned to hit =Command-S= compulsively, so let's make this save the buffer rather than center the line.

#+name: keybindings-save
#+BEGIN_SRC emacs-lisp
;; Forgive my muscle memory
(global-set-key (kbd "M-s") 'save-buffer)
#+END_SRC

- =C-z= is bound to iconify-frame by default, which I never use. Set it to undo instead.

#+name: keybindings-save
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-z") 'undo)

#+END_SRC

*** Mac keyboard settings

I use Emacs on OS X and get my builds from http://emacsformacosx.com/. There are a couple of things I need to configure to make Emacs.app play nicely on a Mac.

First, I want to treat Command *and* Option keys as Meta in Emacs. I know, this is weird. I may eventually change one of these to Super or Hyper. But for now, I like having large target areas for hitting Meta, since I use it so often.

#+name: UI-mac-settings-meta
#+BEGIN_SRC emacs-lisp
;; I'm a Mac
(setq ns-alternate-modifier (quote meta))
(setq ns-command-modifier (quote meta))
#+END_SRC

*** Use Mac clipboard for copying/killing

Copy and paste should use the OS clipboard.

#+name: mac-settings-clipboard
#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)

#+END_SRC

*** Mouse settings for OS X

Emulate a three-button mouse for copy/paste/select:

#+name: UI-mac-settings-clipboard
#+BEGIN_SRC emacs-lisp
(setq mac-emulate-three-button-mouse t)

#+END_SRC


** Cursor and Scrolling
*** Highlight cursor location

I realize a lot of people hate blinking cursors, but I like them because:

- I can quickly find my cursor on a large screen
- The persistent blinking indicates Emacs is waiting for my input --- it's pushing me to write, to get shit done. 

#+name: UI-cursor
#+BEGIN_SRC emacs-lisp
;; show me where I am
(setq blink-cursor-mode t)
#+END_SRC

Another helpful indicator: I like having my current line highlighted. =grey93= is nice and subtle against a white background.

#+name: UI-highlight-line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
(set-face-background 'hl-line "grey93")

#+END_SRC

If you're using a dark theme, you should probably change this.

*** Cursor scroll settings

Let's make buffer scrolling / paging a bit more sane.

By default, Emacs will recenter on the cursor when you scroll above / below the current viewable area. This leads to some disorienting jumping around.

Setting =scroll-conservatively= to a value > 100 means automatic scrolling will never center on the cursor.

#+name: UI-scroll-conserv
#+BEGIN_SRC emacs-lisp
;; Don't scroll like a maniac, pls
(setq scroll-conservatively 1000)
#+END_SRC

The =scroll-margin= variable controls how close to the bottom/top edge of the frame I can get before the viewable area begins to scroll. I like to get right up to the bottom edge before scrolling.

#+name: UI-scroll-margin
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 0)
#+END_SRC

I don't want to jump around at all when scrolling up or down.

And when I *do* page up or down, I want my cursor to be in the same position relative to the top and bottom of the frame.

This just makes sense: When I page up or down with =M-v= or =C-v= I shouldn't have to hunt for my cursor. I should still be looking at it.

#+name: UI-scroll-agg
#+BEGIN_SRC emacs-lisp
  (setq scroll-up-aggressively nil
	scroll-down-aggressively nil
	scroll-preserve-screen-position t)

#+END_SRC

*** Scrolling when on fringe

Scolling via mouse wheel / trackpad works great, except if my mouse is on the fringe (which I set to be extra-wide), or on the mode-line. Let's bind margin and mode-line scroll events appropriately:

#+name: keybindings-scroll
#+BEGIN_SRC emacs-lisp
;; Respect the power of my mouse wheel, margins!
(global-set-key (kbd "<left-margin><wheel-down>") 'mwheel-scroll)
(global-set-key (kbd "<left-margin><wheel-up>") 'mwheel-scroll)
(global-set-key (kbd "<right-margin><wheel-down>") 'mwheel-scroll)
(global-set-key (kbd "<right-margin><wheel-up>") 'mwheel-scroll)
(global-set-key (kbd "<mode-line><wheel-down>") 'mwheel-scroll)
(global-set-key (kbd "<mode-line><wheel-up>") 'mwheel-scroll)

#+END_SRC

*** Scroll view without moving cursor

Use =M-n= and =M-p= to scroll the window view up or down... without moving the point. This is handy for quickly peeking beyond the bounds of the screen without losing my place.

#+name: keybindings-scroll-view
#+BEGIN_SRC emacs-lisp
;; Scroll around the cursor
(global-set-key "\M-n" 'scroll-up-line)
(global-set-key "\M-p" 'scroll-down-line)

#+END_SRC

*** Selecting and deleting text

When I select text between point and mark, I want to see this selection highlighted with transient-mark mode. I find it difficult to use Emacs effectively without having transient-mark-mode turned on.

Delete-selection-mode is also important to me --- it allows overwriting selected text to work the way I expect.

#+name:cursor-transient
#+BEGIN_SRC emacs-lisp
;; Select text in a non-psychopathic way
(transient-mark-mode t)
(delete-selection-mode t)

#+END_SRC

*** Rectangle selection

CUA mode has [[https://www.youtube.com/watch?v=k-6BVjlBSVo][a really nice facility for editing rectangular regions]]. 

I dislike using CUA-mode's default keybindings, but I do like the rectangle editing features. So I turn off the CUA-keys, then turn on CUA.

#+name:cursor-transient
#+BEGIN_SRC emacs-lisp
;; Enable rectangle editing, but not all the other CUA hoo-hah
(setq cua-enable-cua-keys nil)               
(cua-mode t)

#+END_SRC
** Desktop & Bookmark Settings

Emacs Desktop allows you to save your current workspace (frame dimensions, window configuration, open buffers, command and file history, and a bunch of other settings).

#+name: desktop-settings
#+BEGIN_SRC emacs-lisp
;; Save my place
(desktop-save-mode 1)
(setq desktop-globals-to-save
      (append '((extended-command-history . 30)
                (file-name-history        . 100)
                (grep-history             . 30)
                (compile-history          . 30)
                (minibuffer-history       . 50)
                (query-replace-history    . 60)
                (read-expression-history  . 60)
                (regexp-history           . 60)
                (regexp-search-ring       . 20)
                (search-ring              . 20)
                (shell-command-history    . 50)
                tags-file-name
                register-alist)))
#+END_SRC

Don't warn me about desktop locks.

#+name: desktop-lock-warn
#+BEGIN_SRC emacs-lisp
(setq desktop-load-locked-desktop t)
(desktop-read)
#+END_SRC

Define my bookmarks file and save all my settings inside it.

#+name: desktop-settings
#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat dotemacs-dir "bookmarks"))

#+END_SRC


** Window Navigation

*** Move to other window

I use =M-o= to move between windows. The default =C-x o= keybinding is a bit clunky.

#+name: window-other-window
#+BEGIN_SRC emacs-lisp
;; because I don't use set-face and C-x o is just too much
(global-set-key (kbd "M-o") 'other-window)

#+END_SRC

*** Previous buffer when splitting window 

Whenever I split my frame into multiple windows (e.g. with =C-x 2= or =C-x 3=), Emacs will open the current buffer in both windows. This isn't always useful.

Usually what I actually want is to show the previous buffer in that new window. [[http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury][I stole this nice snippet from /r/emacs user chldury]]:

#+name: window-split
#+BEGIN_SRC emacs-lisp
;; don't show me the same buffer twice when I split
(defun vsplit-last-buffer ()
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer)
  )
(defun hsplit-last-buffer ()
  (interactive)
   (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer)
  )

(global-set-key (kbd "C-x 2") 'vsplit-last-buffer)
(global-set-key (kbd "C-x 3") 'hsplit-last-buffer)

#+END_SRC

*** Zoom between split window and single window

[[http://ignaciopp.wordpress.com/2009/05/23/emacs-manage-windows-split/][This function from Ignacio Paz Posse]] has totally replaced [[https://www.emacswiki.org/emacs/WinnerMode][winner-mode]] for me. 

It allows me to move from a split-window view (e.g. two buffers side by side) and "zoom" into one of those buffers, taking it full-frame... and allows me to quickly "zoom" back to the same split-window view.

#+name: window-zoom
#+BEGIN_SRC emacs-lisp
;; Let me jump between a split frame and single-window view
(defun toggle-windows-split()
  "Switch back and forth between one window and whatever split of
windows we might have in the frame. The idea is to maximize the
current buffer, while being able to go back to the previous split
of windows in the frame simply by calling this command again."
  (interactive)
  (if (not(window-minibuffer-p (selected-window)))
      (progn
        (if (< 1 (count-windows))
            (progn
              (window-configuration-to-register ?u)
              (delete-other-windows))
          (jump-to-register ?u)))))

(define-key global-map (kbd "C-`") 'toggle-windows-split)
(define-key global-map (kbd "C-~") 'toggle-windows-split)

#+END_SRC

This is really only useful when jumping between a set of split windows and a single-window view. If I did more jumping between different split-window setups, I'll go back to winner-mode.

*** Shrink/expand windows

Sometimes I want to adjust the size of a window in my split-frame configuration. For example, I may not want my split at 50%, I may want 75% of my frame filled with a view into my source code and 25% showing a REPL. 

I can use the mouse to drag the window boundaries, sure... but it's sometimes faster to do it with my hands on the keyboard:
 
#+name: window-shifting
#+BEGIN_SRC emacs-lisp
;; let me resize windows mouse-free
(define-key global-map (kbd "C-M-<left>") 'shrink-window-horizontally)
(define-key global-map (kbd "C-M-<right>") 'enlarge-window-horizontally)
(define-key global-map (kbd "C-M-<up>") 'enlarge-window)
(define-key global-map (kbd "C-M-<down>") 'shrink-window)

#+END_SRC

** File & Buffer Navigation & Manipulation
*** Buffer lists

I really like ibuffer for listing all open buffers. I've bound it to =C-x C-b=. 

#+name: ibuffer
#+BEGIN_SRC emacs-lisp
;; I heart ibuffer
(global-set-key "\C-x\C-b" 'ibuffer)

#+END_SRC

*** Edit filenames in dired

Dired is awesome for viewing and manipulating files in a directory. wdired makes it even more awesome --- it lets you edit filenames in a dired buffer (editing them just like any text file), then save your changes to bulk-rename files and more.

I like having wdired bound to the 'r' key inside dired.

(note that I'm eval-ing this *only after* loading dired, otherwise Emacs chokes on an undefined dired-mode-map var)

#+name: wdired
#+BEGIN_SRC emacs-lisp
;; bulk-edit files in dired
(eval-after-load 'dired
  '(define-key dired-mode-map "r"
     'wdired-change-to-wdired-mode))

#+END_SRC

*** Open Finder window or file from dired

Sometimes when I'm looking at a directory, I want to flip over to see it in the Finder. Or if I'm in dired and my pointer's on a .doc file or something, I'll want to open it using the default OS X application. This elisp snippet was stolen from [[http://jblevins.org/log/dired-open][Jason Blevins]].

I've bound this to 'z' within dired.

#+name: dired-open
#+BEGIN_SRC emacs-lisp
;; open outside Emacs (blasphemy!)
(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map (kbd "z")
       (lambda () (interactive)
         (let ((fn (dired-get-file-for-visit)))
           (start-process "default-app" nil "open" fn))))))

#+END_SRC


*** Make =C-<= and =C->= work nicely in dired-mode

Thanks to Magnar Sveen for this one. This snippet makes =C-<= and =C->= send the cursor to the beginning/end of the filenames in dired buffers. Handy!

#+name: dired-c-a
#+BEGIN_SRC emacs-lisp
;; dired needs a ceiling and a floor
(defun dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (dired-next-line 4))

(eval-after-load 'dired
  '(define-key dired-mode-map
    (vector 'remap 'beginning-of-buffer) 'dired-back-to-top))

(defun dired-jump-to-bottom ()
  (interactive)
  (end-of-buffer)
  (dired-next-line -1))

(eval-after-load 'dired
  '(define-key dired-mode-map
    (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom))

#+END_SRC

*** Rename and delete files

Renaming and deleting files should be easier to do while you're viewing them.

Since =C-x k= kills a buffer, it makes sense to bind =C-x C-k= to deleting the current file (with confirmation, of course).

And =C-x C-w= is bound to write-file... but a more useful feature would be to simple rename the current buffer and file. This is bound to =C-x C-r=.

#+name: rename-and-delete-files
#+BEGIN_SRC emacs-lisp
;; rename a file in place
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))
(global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

;; nuke this file (scream emoji)
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename t)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))
(global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
#+END_SRC

*** Drag and drop file support

When I drag and drop a file onto Emacs.app, visit that file rather than just appending it to the currently open buffer (which is a horrible default).

#+name: Filenav-drag-n-drop
#+BEGIN_SRC emacs-lisp
;; don't do dumb things
(define-key global-map [ns-drag-file] 'ns-find-file) 

#+END_SRC

*** Make M-x locate use OS X's Spotlight

Leverage OS X's mdfind util for crazy-fast file locating. Try it with =M-x locate=.

#+name: locate-spotlight
#+BEGIN_SRC emacs-lisp
;; search with a spotlight
(setq locate-make-command-line (lambda (s) `("mdfind" "-name" ,s)))

#+END_SRC

*** Re-open file as root

[[http://t.co/KiAWcJoo][Thanks to @christopherdone for this one]]. I occasionally need to edit a file as root. This is possible to do within my running Emacs instance with [[Tramp][tramp]], but I usually forget exactly how to do it. 

This function encapsulates this inside an easier-to-remember function name. If I type =M-x sudo=, I'll get =tramp-sudo-reopen= in my autocomplete list.

#+name: open-as-root
#+BEGIN_SRC emacs-lisp
;; I've got the power
(defun tramp-sudo-reopen ()
  "Re-open the current with tramp."
  (interactive)
  (let ((file-name (format "/sudo:localhost:%s" (buffer-file-name)))
        (line (line-number-at-pos))
        (column (current-column)))
    (kill-buffer)
    (find-file file-name)
    (goto-line line)
    (goto-char (+ (point) column))))

#+END_SRC
*** Hide auto-revert-mode

I like having auto-revert-mode on in certain files that I know are going to change a lot from processes outside Emacs.

I don't want to see =auto-revert= in the modeline.

#+name: diminish-auto-revert
#+BEGIN_SRC emacs-lisp
;; Hide your shame
(diminish 'auto-revert-mode)
#+END_SRC


** Alerts and Notifications

I use [[https://github.com/julienXX/terminal-notifier][terminal-notifier]] to send alerts to the OS X Notification Center from other applications. I adapted [[https://gist.github.com/justinhj/eb2d354d06631076566f#file-gistfile1-el][this gist from justinhj]] to send events from emacs to the Notification Center.

Note that this depends on having terminal-notifier installed. If you use homebrew, just use =brew install terminal-notifier=.

#+name: UI-notifications
#+BEGIN_SRC emacs-lisp
;; terminal-notifier-notify is my messenger god
(defvar terminal-notifier-command (executable-find "terminal-notifier") "The path to terminal-notifier.")

(defun terminal-notifier-notify (title message)
  "Show a message with `terminal-notifier-command`."
  (start-process "terminal-notifier"
                 "*terminal-notifier*"
                 terminal-notifier-command
                 "-title" title
                 "-message" message
                 "-activate" "org.gnu.Emacs"))

#+END_SRC
** Set garbage collection threshold higher

Props to Le Wang for this one.

[[https://github.com/lewang/flx][According to his documentation in flx]], Emacs will start GC every 0.76MB allocated, which is way too often on modern machines. We want to boost that to 20MB:

#+name: setup-gc-settings
#+BEGIN_SRC emacs-lisp
;; build a giant garbage compactor
(setq gc-cons-threshold 20000000)

#+END_SRC


* Writing Fiction

I spend a bunch of my time in Emacs writing fiction. Some of it has [[https://web.archive.org/web/20120502210836/http://prismmagazine.ca/2011/10/10/jeff-stautz-on-asymptote-his-national-magazine-award-winning-short-story/][won awards.]] 

I'm pretty sure my small amounts of writing success can be attributed to my Emacs config. 

** Auto-fill & Word Wrap

By default, Emacs doesn't automatically wrap words onto the next line. (I know! What decade are we in?)

There are two options to change this. 

In the first option, =auto-fill-mode= will automatically insert linebreaks at a certain column number, preventing any lines from being longer than your screen's viewable area. Setting the =fill-column= variable defines the column number at which Emacs will auto-insert a linebreak.

In the second option, =visual-line-mode=, no linebreaks are inserted in your text (it's all actually one line in the text file), but it's *visually* wrapped onto multiple lines. Cursor movement, end-of-line, and beginning-of-line commands all work within the wrapped line. 

The second option is more like a "modern" word processor, but still has its quirks.

*** Auto-fill-mode

I typically run Emacs.app in full screen, and a 120-character fill-column feels pretty good to me. Especially when I'm writing or editing fiction.

#+name: auto-fill-options
#+BEGIN_SRC emacs-lisp
;; just my size
(setq fill-column 120)
(setq default-fill-column 120)

#+END_SRC

*** Visual-line mode and wrap-to-fill-column

Previously I kept auto-fill-mode turned on. The hard linebreaks didn't bother me, and when diffing files in my git repo of creative writing, I could view changes on individual lines.

However... it's still kind of a pain in the ass.

Visual-line-mode would be a fantastic alternative, and it works great... except that it wraps to the *full width of the frame.* I usually have my frame full-screen and like working in a narrower band within this frame, my text surrounded by whitespace.

I've since discovered wrap-to-fill-column-mode (was previously packaged with nxhtml-mode --- I've pulled it out in my .emacs.d directory). This allows me to use visual-line-mode for word wrapping, yet keeps the lines to a reasonable length. It also centers the text nicely in my window.

#+name: wrap-fill-options
#+BEGIN_SRC emacs-lisp
;; float my text in the middle, all pretty-like
(load-file "~/.emacs.d/lisp/wrap-to-fill.el")
(visual-line-mode 1)
(wrap-to-fill-column-mode 1)
(add-hook 'text-mode-hook '(lambda() (wrap-to-fill-column-mode 1)))
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)

#+END_SRC

And we'll use diminish to keep those always-on modes from cluttering up our pretty mode-line.

#+name: wrap-fill-diminish
#+BEGIN_SRC emacs-lisp
;; hide that nonsense from the mode-line
(diminish 'visual-line-mode)
(diminish 'wrap-to-fill-column-mode)

#+END_SRC


*** Unfill-paragraph

I sometimes want to "unfill" a paragraph --- that is, take a block of text that's had hard linebreaks inserted into it, and turn it into a single line of text. 

I borrowed this snippet from [[https://raw.github.com/qdot/conf_emacs/master/emacs_conf.org][Kyle Machulis]].

#+name: writing-unfill-paragraph
#+BEGIN_SRC emacs-lisp
;; fables of the reconstruction
(defun unfill-paragraph ()
  "Takes a multi-line paragraph and mashes it into a single line of text."
  (interactive)
  (let ((fill-column (point-max)))
    (fill-paragraph nil)))

#+END_SRC

This is especially relevant now that I've ditched auto-fill, relying on visual-line-mode rather than hard line breaks. I find myself revising old pieces of writing and wanting to update them to work better with visual-line-mode, and this function helps.

(Note: I should really rework this function so it operates on the entire buffer.)


** Tabs, spaces, EOL characters

I am firmly in the "spaces" camp on the whole "tabs v. spaces" debate. I also like my tabs to insert 4 spaces.

#+name: writing-tabs
#+BEGIN_SRC emacs-lisp
;; herein I set down fundamental laws of nature
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+END_SRC

And don't even get me started on one space vs. two after sentences. Because Jesus, people.

#+name: writing-spaces
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
  
Also, lines should end in plain old LFs, as god intended.

#+name: UI-mac-settings-eol
#+BEGIN_SRC emacs-lisp
(setq eol-mnemonic-mac "(Mac)")

#+END_SRC
** Spell-check settings

[[file:img/flyspell-popup.png]]

I like using aspell for spell checking in Emacs.

Note that aspell may not be installed by default. If you're on a Mac, the easiest way to do that is with homebrew: =brew install aspell=. This should install aspell along with the english-language dictionaries you need.

#+name: spell-check-aspell
#+BEGIN_SRC emacs-lisp
;; I love ispell
(setq ispell-program-name "aspell")

#+END_SRC

Aspell doesn't recognize the Canadian dictionary by default. 

This is, quite frankly, insulting. It's a borderline act of war. 

So let's teach Emacs about Canada before it starts an international incident, eh?

#+name: spell-check-canadian
#+BEGIN_SRC emacs-lisp
;; sorry, I'm Canadian
(defvar ispell-local-dictionary-alist
  '(("canadian"
     "[A-Za-z]" "[^A-Za-z]" "[']" nil ("-B") nil iso-8859-1)))
(setq ispell-local-dictionary "canadian")

#+END_SRC

Now that we've got ispell working, it's easy to activate spell-checking as you type with flyspell. Just hit =M-x flyspell-mode= and you've got those nifty red underlines highlighting all your mistakes.

Let's activate flyspell-mode by default for text-mode and org-mode buffers:

#+name: flyspell-defaults
#+BEGIN_SRC emacs-lisp
;; fly, you fools
(add-hook 'text-mode-hook (lambda () (flyspell-mode 1)))
(add-hook 'org-mode-hook (lambda () (flyspell-mode 1)))
#+END_SRC

Of course, highlighting the words isn't enough. I'd like a quick way to fix them. And I don't like fly spell's default way of doing this. Let's bind =C-;= to =ispell-word= when we're in flyspell mode and the pointer's on a misspelled word.

#+name: ispell-word-at-point
#+BEGIN_SRC emacs-lisp
(eval-after-load "flyspell"
  '(define-key flyspell-mode-map (kbd "C-;") #'ispell-word))
(eval-after-load "minor-mode"
  '(define-key flyspell-mode-map (kbd "C-c $") nil))

#+END_SRC

And there are a few sections of org-mode files that we should ignore ([[https://github.com/grettke/home/blob/master/ALEC.org#L4546][stolen from Grant Rettke]]).

Never spell check inside org-mode source blocks:

#+name: ispell-skip-src
#+begin_src emacs-lisp
;; rocks ispell just shouldn't look under:
(add-to-list 'ispell-skip-region-alist '("^#\\+begin_src ". "#\\+end_src$"))
(add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC ". "#\\+END_SRC$"))
#+end_src

Or inside org-mode example blocks:

#+name: ispell-skip-example
#+begin_src emacs-lisp
(add-to-list 'ispell-skip-region-alist '("^#\\+begin_example ". "#\\+end_example$"))
(add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_EXAMPLE ". "#\\+END_EXAMPLE$"))
#+end_src

Or inside org-mode Properties blocks:

#+name: ispell-skip-properties
#+begin_src emacs-lisp
(add-to-list 'ispell-skip-region-alist '("\:PROPERTIES\:$" . "\:END\:$"))

#+end_src



** Narrow-to-region

When I'm writing or working, I find it useful to be able to focus on a narrow region of text. The =narrow-to-region= command, when invoked on a selected region of text, will hide everything else in the buffer except for that text. 

It's as if you're editing a file containing *only* that information --- you can't see anything else, can't scroll beyond it, etc. In addition, most editing commands will only apply to the narrowed region of the buffer. 

It's pretty damn handy. It's also disbled by default, so let's turn it on.

#+name: writing-narrow
#+BEGIN_SRC emacs-lisp
;;;; Remove some guard rails
(put 'narrow-to-region 'disabled nil)
#+END_SRC
** Upcase / downcase

Upcase-region and downcase-region are disabled by default. Let's turn them on. 

#+name: writing-upcase
#+BEGIN_SRC emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)

#+END_SRC

** Marked.app integration

When I'm writing in Markdown, I'll want to preview what I'm writing in Brett Terpstra's good-ol' Marked.app. 

I stole this from https://github.com/mattsears/emacs:

#+name: writing-marked-app
#+BEGIN_SRC emacs-lisp
;; open Marked and show me what we got
(defun markdown-preview-file ()
  "run Marked on the current file and revert the buffer"
  (interactive)
  (shell-command
   (format "open -a /Applications/Marked.app %s"
           (shell-quote-argument (buffer-file-name)))))
(global-set-key "\C-cm" 'markdown-preview-file)

#+END_SRC

I've also added a [[https://github.com/jstautz/writing-tools/blob/master/manuscript.css][css file to Marked.app]] in order to format my Markdown to look more like a standard "manuscript format."

** Fiction templates

I do most of my writing in Emacs org-mode, and I've created [[https://raw.githubusercontent.com/jstautz/writing-tools/master/fiction_template.org][a specific org-mode template for writing short fiction]].

It contains LaTeX headers and front-matter that will produce a correctly-formatted manuscript suitable for submission, complete with appropriate headers, double spacing, page numbers, etc.

It's also got a separate subtree marked as =:noexport:= for holding all my notes about the story and characters, links to research, and raw journal entries -- none of which are included when exporting the manuscript.

Note that this template relies on some non-standard LaTeX packages that I've got [[https://github.com/jstautz/writing-tools][squirrelled away in this repo]] so they're easy for me to find again in the event that my LaTeX environment gets wiped.
* Writing Code
** Return + indent

I like it when my return key preserves indentation:

#+name: coding-return-indent
#+BEGIN_SRC emacs-lisp
;; do the right thing
(global-set-key (kbd "RET") 'newline-and-indent)

#+END_SRC
** Tags

A smarter find-tag that automagically reruns etags when it can't find a requested item and then makes a new try to locate it.

I stole this from Jonas.Jarnestrom<at>ki.ericsson.se.

#+name: coding-reload-tags
#+BEGIN_SRC emacs-lisp
;; refresh and find tags
(defadvice find-tag (around refresh-etags activate)
  "Rerun etags and reload tags if tag not found and redo find-tag.
   If buffer is modified, ask about save before running etags."
  (let ((extension (file-name-extension (buffer-file-name))))
    (condition-case err
        ad-do-it
      (error (and (buffer-modified-p)
                  (not (ding))
                  (y-or-n-p "Buffer is modified, save it? ")
                  (save-buffer))
             (er-refresh-etags extension)
             ad-do-it))))

(defun er-refresh-etags (&optional extension)
  "Run etags on all peer files in current dir and reload them silently."
  (interactive)
  (shell-command (format "etags *.%s" (or extension "el")))
  (let ((tags-revert-without-query t))  ; don't query, revert silently
    (visit-tags-table default-directory nil)))

#+END_SRC

...And if my etags file gets rebuilt at any point, don't pester me about it, just use the updated file:

#+name: coding-rebuild-tags
#+BEGIN_SRC emacs-lisp
(setq tags-revert-without-query t)

#+END_SRC

When navigating via tags and I pop back to my original location, I want to make sure the cursor is centered on the screen and easy to spot. I do this by modifying the =pop-tag-mark= function like this:

#+name: coding-pop-tag
#+BEGIN_SRC emacs-lisp
;; let me jump back, please
(defadvice pop-tag-mark (after my-pop-tag-mark-advice activate)
  "After popping back to where find-tag was invoked,
   center screen on cursor"
  (let ((current-prefix-arg '(4)))
  (call-interactively 'recenter-top-bottom)))

#+END_SRC

** Emacs Lisp
*** Bind ESC to top-level command

I hate having to repeatedly hit escape to bounce out of recursive edits when I drop into the debugger.

#+name: coding-escape-top-level
#+BEGIN_SRC emacs-lisp
;; Escape is my eject button
(global-set-key (kbd "<C-escape>") 'top-level)
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(add-hook 'org-mode-hook
          (lambda()
            (define-key org-mode-map (kbd "<escape>") 'keyboard-escape-quit)))

#+END_SRC

*** eval and replace

When I'm working with elisp, it's sometimes useful to quickly evaluate an s-expression and immediately replace it with the result.

#+name: coding-eval-replace
#+BEGIN_SRC emacs-lisp
;; presto change-o
(defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (prin1 (eval (read (current-kill 0)))
           (current-buffer)))
  (global-set-key (kbd "C-c e") 'eval-and-replace)

#+END_SRC

*** auto-recompile elisp

If I'm working on an elisp file that has a corresponding compiled version (*.elc), I want to re-compile whenever I save the buffer.

#+name: coding-auto-recompile
#+BEGIN_SRC emacs-lisp
;; auto-recompile on save
(defun byte-compile-current-buffer ()
  "`byte-compile' current buffer if it's emacs-lisp-mode and compiled file exists."
  (interactive)
  (when (and (eq major-mode 'emacs-lisp-mode)
             (file-exists-p (byte-compile-dest-file buffer-file-name)))
    (byte-compile-file buffer-file-name)))
(add-hook 'after-save-hook 'byte-compile-current-buffer)

#+END_SRC


** Tramp

#+name: coding-tramp
#+BEGIN_SRC emacs-lisp
;; obvious default is obvious
(setq tramp-default-method "ssh")

#+END_SRC

** Diff

Add some flags to the default diff command so it works with .org files and others.

#+name: coding-diff
#+BEGIN_SRC emacs-lisp
(setq diff-switches "-a -c")

#+END_SRC


* Org-mode
:PROPERTIES:
:noweb-ref: Set up org-mode
:END:

** Load org-mode setup (still need to get this into separate org doc)

#+name: hacks-org-setup
#+BEGIN_SRC emacs-lisp
(load-file "~/.emacs.d/lisp/init-org-mode.el")
;;(org-babel-load-file (expand-file-name "org-mode-init.org" (file-name-directory (or load-file-name (buffer-file-name)))) t)
#+END_SRC
