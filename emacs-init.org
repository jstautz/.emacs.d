#+TITLE: Jeff's Emacs config
#+AUTHOR: Jeff Stautz
#+EMAIL: jeff@jeffstautz.com
#+LANGUAGE:  en
#+OPTIONS: toc:nil num:nil ^:nil H:4
#+PROPERTY: header-args :tangle "lisp/emacs-init.el"

#+begin_quote
People talk about getting used to a new editor, but over time, it is precisely the opposite that should happen --- the editor should get used to us.

--- [[http://blog.vivekhaldar.com/post/31970017734/new-frontiers-in-text-editing][Vivek Hadlar]]
#+end_quote

#+TOC: headlines 2

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

** What is this?
:PROPERTIES:
:CUSTOM_ID: what_is_this
:END:

It's a [[http://en.wikipedia.org/wiki/Literate_programming][literate programming]] version of my Emacs config files.

My current setup borrows liberally from Emacs users far smarter than I am, including: 
- [[http://doc.norang.ca/org-mode.html][Bernt Hansen]] 
- [[https://github.com/eschulte/emacs24-starter-kit][Eric Schulte]]
- [[https://github.com/magnars/.emacs.d][Magnar Sveen]]
- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]]
- [[https://github.com/technomancy/dotfiles][Phil Hagelberg]]
- [[https://github.com/bodil/emacs.d][Bodil Stokke]]
- [[http://www.masteringemacs.org/][Mickey Petersen]]
- And a ton of others. 

Props and praises are scattered throughout my config in places where I can remember who I stole something from.

** What's literate programming?
:PROPERTIES:
:CUSTOM_ID: what_is_literate
:END: 

Short answer: instead of writing separate documentation, the documentation /contains/ the program. The code itself is secondary to the explanation about how it works.

Or as Knuth puts it:

#+begin_quote 
Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on /explaining to humans/ what we want the computer to do.

--- Donald E. Knuth, Literate Programming, 1984
#+end_quote

The document you're reading now is an [[http://org-mode.org][org-mode]] text file that contains both code *and* documentation. 

On startup, emacs pulls out ("tangles") the code snippets in this file and uses them to configure the editor.

** Why would you use literate programming for your Emacs config?
:PROPERTIES:
:CUSTOM_ID: why_literate
:END:

It's an experiment. We'll see how well it works out.

I've been inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's literate emacs config]], as well as by [[http://doc.norang.ca/org-mode.html][Bernt Hansen's amazingly thorough and detailed documentation of his org-mode setup]].

Using a literate programming approach has a number of advantages that appeal to me:

1. *Better organization of my .emacs lisp files*
   - My elisp code snippets are embedded within the foldable goodness of org-mode's outline structure.
   - My configuration is better organized and easier to understand.

2. *I'm better able to follow my own thought processes.*
   - Explanations take priority, code is secondary.
   - When I revisit code I wrote ten years ago, I have a hope of understanding /what the hell I was thinking./

3. *Sharing my setup is easier*
   - I have one file that generates nice-looking documentation and the code itself.
   - Detailed explanations of my setup mean it's easier for others to understand it and benefit from it.

* Structure --- how this works 
:PROPERTIES:
:CUSTOM_ID: structure
:END:

Before we get too deep into my settings, I should explain a little about how all this works.

** init.el
:PROPERTIES:
:CUSTOM_ID: init.el
:END:

My init.el file is only a half-dozen lines of elisp. Its only real job is to bootstrap the rest of my config by loading it via org-babel.

It looks like this:

#+BEGIN_EXAMPLE emacs-lisp
(package-initialize)

;; Assume the current directory is our dot-emacs directory
(setq dotemacs-dir (file-name-directory (or load-file-name (buffer-file-name))))

;; If emacs-init.el is *newer* than emacs-init.org, then load the *.el file directly.
;; Otherwise, tangle the *.org file and load.
(if (> (string-to-int (shell-command-to-string "stat -f \"%m\" ~/.emacs.d/lisp/emacs-init.el"))
       (string-to-int (shell-command-to-string "stat -f \"%m\" ~/.emacs.d/emacs-init.org")))
      (load-file (expand-file-name "lisp/emacs-init.elc" dotemacs-dir))
  (org-babel-load-file (expand-file-name "emacs-init.org" dotemacs-dir) t))
#+END_EXAMPLE

That's it.

The important part is that last s-expression: 

#+BEGIN_EXAMPLE emacs-lisp
(org-babel-load-file (expand-file-name "emacs-init.org" dotemacs-dir) t)
#+END_EXAMPLE

This line calls org-babel to extract ("tangle") the code blocks from the =emacs-init.org= file into a file called =emacs-init.el=, then compile it. It then tells Emacs to load all the configurations in that compiled .elc file.

[[http://orgmode.org/worg/org-contrib/babel/][Org-babel is Merlin-level wizardry.]] Eric Schulte, Dan Davison, and everyone who's worked on it all deserve medals. 

Because tangling and loading my .org file takes a few seconds, I've wrapped this call to org-babel in an =if= statement that checks to see if any recent changes have been made to the org file. 

** emacs-init.org
:PROPERTIES:
:CUSTOM_ID: emacs-init.org
:END:

The =emacs-init.org= file is the meat of my emacs config. It's also the document you're reading right now.

When this document is tangled and loaded by org-babel, =emacs-init.el= is updated with the latest elisp extracted from code blocks in this file.

I try to treat the resulting =emacs-init.el= file like /compiled code/. I try not to look at it too often, except when debugging.

Any edits or changes, even if they're experimental, are made in the .org file instead of directly in the .el file. This way, I'm ensuring my documentation always stays up to date.

** Packages 
:PROPERTIES:
:CUSTOM_ID: packages
:END:

Back in the dark ages, I would find third-party elisp packages on the interwebs and install them manually. This got nasty pretty quickly.

Emacs 24 introduced a really nice package management system, =package.el=. I used it for a while on its own, then supplemented it with [[https://github.com/jwiegley/use-package][use-package]].

*** package.el
:PROPERTIES:
:CUSTOM_ID: package.el
:END:

Use =M-x package-list-packages= to browse packages on all source repos, then install/uninstall/update them from within Emacs.

Here's what it looks like:

[[file:img/list-packages.png]]

Before using the package manager, I want to add a few other sources (notably [[http://melpa.milkbox.net/#/][melpa]] and the org-mode source) to my package source list.
  
#+name: package-set-sources
#+BEGIN_SRC emacs-lisp
;; set package sources
(dolist (source '( ("gnu"   . "http://elpa.gnu.org/packages/")
                   ("elpa"  . "http://tromey.com/elpa/")
		         ("org"   . "http://orgmode.org/elpa/")
                   ("melpa" . "http://melpa.milkbox.net/packages/")))
  (add-to-list 'package-archives source t))
(package-initialize)

#+END_SRC

*** use-package
:PROPERTIES:
:CUSTOM_ID: use-package
:END:

[[https://github.com/jwiegley/use-package][John Wiegley's use-package]] provides some really nice macros for autoloading and configuring packages. It handles a lot of things for me out of the box, including:

- Grabbing any missing packages from the internet
- Initializing and autoloading packages
- Nicely isolating package-specific configs
- Setting keybindings in a very readable way
- Deferring configuration elisp until after a package actually gets used
- And more!

First, let's grab =use-package= from elpa if it's not already installed. 

#+name: package-install-use-package
#+BEGIN_SRC emacs-lisp
;; install use-package, which my setup relies on
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

#+END_SRC

Now let's load =use-package=, and then set it up so that any package we try to load is treated as if we've specified the =:ensure= keyword --- meaning that if the package isn't present on the system, we'll download it from the interwebs.

#+name: package-use-package
#+BEGIN_SRC emacs-lisp
(require 'use-package)
(setq use-package-always-ensure t)

#+END_SRC

*** /elpa directory

When I install any packages (either via =use-package= or manually with package.el), they're saved in my =~/.emacs.d/elpa/= directory.

In the past, I kept this directory in my .gitignore, so that I wasn't saving a ton of third party packages in my .emacs github repo. 

In reality, this caused more problems for me than it was worth. 

Whenever I wanted to use Emacs on a new machine, my config would pull down new copies of packages off the internet --- which is great! --- BUT then I'd spend the next three days trying to sort out dependency issues and breaking changes with the latest versions of several packages.

I found that I'd much rather check *everything* in, so that I've got a "known working state" I can check out at any time.

* How I Use Emacs
:PROPERTIES:
:CUSTOM_ID: how-i-use-emacs
:END:

#+begin_quote
This is my rifle. There are many like it, but this one is mine.

--- Major General William H. Rupertus, "The Rifleman's Creed," 1942
#+end_quote

Before we get into the actual configuration, it might help to understand some things I do in Emacs.

My use of Emacs is by no means typical, and my configuration reflects this fact.

** Org-mode

[[file:img/org.png]]

I spend 90% of my time in Emacs inside [[http://orgmode.org/][org-mode]]. 

I've been using it for several years for taking notes, planning, writing, and tracking my to-do lists. It's a brilliant piece of software that's totally changed how I organize my digital life. 

I've got a whole separate section of my Emacs config dedicated to the ins and outs of my org-mode configuration. It's gnarly. It's complicated. But it /works/ for me. 

** Writing

For the last 12+ years, I've done most of my fiction writing, journalling, editing, and revising in plain text within Emacs.

Sometimes I work in [[https://daringfireball.net/projects/markdown/][Markdown syntax]] and view the formatted version of my documents in [[http://markedapp.com/][Marked.app]].

Other times I write using minimal [[http://www.latex-project.org/][LaTeX markup]], which I then run through a perl script to add full LaTeX document headers for exporting.

More recently, I've started using the =org-export= features of org-mode in order to create LaTeX and PDF docs.

Details of how I use Emacs for fiction writing are documented later in this file. 

** Programming

Unlike many (most?) Emacs users, I don't develop software professionally anymore.

I've done a bunch of software development work in the past, and I enjoy messing around in code occasionally. I dabble. I pretend like I know what I'm doing. But I'm nowhere near professional.

[[http://hootsuite.com/careers/][I work with a ton of talented engineers every day at Hootsuite]] and they constantly inspire me to learn more, try more, and hack more. 

There are a couple of languages I work with regularly:

- I use Emacs lisp quite a bit (of course)
- I occasionally mangle some Python
- I play around with Javascript
- I'm learning Go

My Emacs settings for software development should be taken with several grains of salt --- these parts of my config aren't very mature and I'm probably doing everything wrong.

** Manipulating files and text of all kinds

Macros, mutli-line editing, directory editing, remote editing over SSH... Emacs is my Swiss Army knife for text and file transformations. 

There are large chunks of my config that deal with sharpening various blades of said Swiss Army knife.

* Prerequisites
:PROPERTIES:
:noweb-ref: Prerequisites and setup --- load basic support libraries, set some useful variables
:CUSTOM_ID: setup
:END:  

Now let's get into the config itself.

This first section contains some libraries and basic settings that the rest of my configuration depends on.

** First, let's load Common Lisp libraries

This is generally a good idea. There's a lot of good stuff in the CL package that many other packages need.

#+name: setup-require-cl :comments both
#+BEGIN_SRC emacs-lisp
(use-package cl)

#+END_SRC

** Then set our path appropriately.

This is a gross hack to grab the $PATH environment variable from my ~/.bashrc and use it. This way my path is consistent between Emacs.app and my shell elsewhere.

#+name: setup-path :comments both
#+BEGIN_SRC emacs-lisp
;; ensure OS X keeps my path consistent in Emacs
(let ((jcs:shell-path (shell-command-to-string ". ~/.bashrc; echo -n $PATH")))
  (setenv "PATH" jcs:shell-path)
  (setq exec-path (split-string jcs:shell-path ":")))

#+END_SRC

Yeah, you read that elisp right. Icky, but it works. This workaround's required because of the way OS X launches apps. The only other solution would be to mess around with =launchctl=, and I really don't want to do that right now.
 
** Set a few variables for directories

Define our home directory, dot emacs directory (where the config lives), emacs binary directory (where Emacs.app lives), and info file directory.

I use these =*-dir= variables all over the place in my config.

Some of these are obviously going to be different in your setup, so you'll want to change them accordingly.

#+name: setup-dirs :comments both
#+BEGIN_SRC emacs-lisp
;; fantastic directories and where to find them
  (defvar home-dir     "/Users/jeff.stautz/")
  (defvar dotemacs-dir (concat home-dir ".emacs.d/"))
  (defvar lisp-dir     (concat dotemacs-dir "lisp/"))
  (defvar emacs-dir    "/Applications/Emacs.app/Contents/")
  (defvar emacs-bin    (concat emacs-dir "MacOS/Emacs"))
  (defvar info-dir     (concat emacs-dir "Resources/info/"))
#+END_SRC

** Add lisp directory to load-path

Our load-path defines where Emacs should look for packages, functions, variables, etc. 

We should add the ~/.emacs.d/lisp/ directory to this list.

#+name: setup-load-path
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path lisp-dir)

#+END_SRC
** Tell 'customize' where to save changes

I don't generally use =M-x customize= --- I prefer to =setq= these variables in my init files manually --- but sometimes I'll fiddle with settings in customize to try things out.

When I do so, I'd like customize to save things in a separate =emacs-custom= file. I treat this file as temporary storage. If I like the changes, I'll pull them out of this file and place them in the appropriate places in my config.

#+name: setup-custom-file
#+BEGIN_SRC emacs-lisp
;; Arr, here be my custom file
(setq custom-file (concat lisp-dir "custom.el"))

#+END_SRC

** Set garbage collection threshold higher

Props to Le Wang for this one.

[[https://github.com/lewang/flx][According to his documentation in flx]], Emacs will start GC every 0.76MB allocated, which is way too often on modern machines. We want to boost that to 20MB:

#+name: setup-gc-settings
#+BEGIN_SRC emacs-lisp
;; build a giant garbage compactor
(setq gc-cons-threshold 20000000)

#+END_SRC

** Decrypt secrets.el.gpg

Passwords, private URLs, and personal info are encrypted and stored in the secrets.el.gpg file. Emacs decrypts this using the keys in my .gnupg keyring.

I do this *before* I begin loading packages, so that package configs can access variables stored in the secrets file.

#+name: setup-decrypt-secrets-function
#+BEGIN_SRC emacs-lisp
(defun jcs:decrypt-secrets ()
  (interactive)
  (require 'secrets))

#+END_SRC

* Install and configure packages

#+begin_quote
Brown paper packages tied up with strings
These are a few of my favorite things

--- Austrian Mary Poppins
#+end_quote

I've settled on a relatively small set of packages for my current Emacs config. 

I'll probably add to this over time, because I just can't help myself.

** Ace-jump mode

It's [[https://www.youtube.com/watch?v=UZkpmegySnc][hard to describe ace-jump-mode unless you see it in action]]. 

Let's say I want to move to the "m" in the word "mentioned" in the line above. I just activate ace-jump-mode (I've bound it to =C-.=), then type "m". At this point, emacs highlights all matches in the buffer, like this:

[[file:img/ace-jump.png]]

Notice each word beginning with "m" now starts with a red letter. I type "b" to jump to the word "mentioned."

#+name: ace-jump
#+BEGIN_SRC emacs-lisp
;; jump around, House of Pain style
(use-package ace-jump-mode
             :bind ("C-." . ace-jump-mode))

#+END_SRC

This is a super-fast way to quickly move your cursor around in the buffer -- handy whether you're working in a text file or with code.

** Browse kill ring

=C-y= yanks from the top of the kill ring, and hitting =C-y M-y, M-y, M-y= repeatedly will cycle through previous kills. But what if you want to browse through the whole kill ring and find that text you killed a few hours ago?

Hitting =M-y= activates browse-kill-ring and let you dig through your kill history, select an item, and yank it into the buffer.

#+name: browse-kill-ring
#+BEGIN_SRC emacs-lisp
;; show me the graveyard with M-y
(use-package browse-kill-ring
             :defer t
             :init
             (progn
               (autoload 'browse-kill-ring-default-keybindings "browse-kill-ring")
               (browse-kill-ring-default-keybindings)))

#+END_SRC

** Diminish mode

I like keeping my mode-line clean.

Diminish is a package that lets you replace the default major/minor mode indicators in the mode-line with shorter abbreviations (or hide them altogether).

#+name: UI-modeline-diminish
#+BEGIN_SRC emacs-lisp
;; use fewer letters
(use-package diminish)

#+END_SRC

Even better, use-package supports diminsh options as part of the declaration when loading packages.

Diminish also features [[http://www.eskimo.com/~seldon/diminish.el][some of the best code comments in the universe]].

** ido & smex

[[file:img/ido.png]]

[[http://emacswiki.org/emacs/InteractivelyDoThings][ido (short for "*interactively do* things")]] is a fantastic package, and one of the first things I recommend a new Emacs user set up. It's actually a part of Emacs as of v22, but requires a bit of configuration to make it *really* powerful.

[[https://www.youtube.com/watch?v=lsgPNVIMkIE][ido provides autocomplete features for files and buffers]], and it supports things like fuzzy matching and "virtual buffers" for revising recently-closed buffers.

*** ido settings

Let's turn on ido and configure it, shall we? It's got a lot of bells and whistles.

The first things we want to do are to enable flex matching, turn ido on everywhere, ignore case when completing, and set up max prospects and faces. 

#+name: ido-settings-1
#+BEGIN_SRC emacs-lisp
;; unlock the magic
(ido-mode t)
(setq ido-enable-flex-matching t
      ido-everywhere t
      completion-ignore-case t           
      read-file-name-completion-ignore-case t
      ido-max-prospects 20
      ido-use-faces t)
#+END_SRC

Next, I want to turn off some of the tramp-related and ftp-related options --- these caused stalls for me in the past.

#+name: ido-settings-2
#+BEGIN_SRC emacs-lisp
(setq ido-record-ftp-work-directories nil
      ido-enable-tramp-completion nil
      ido-is-tramp-root nil)
#+END_SRC

Now let's add some magic: we'll turn on recentf-mode and allow ido to list my recently-closed buffers as possible matches. This is so damn handy.

#+name: ido-settings-3
#+BEGIN_SRC emacs-lisp
(recentf-mode t)
(setq ido-use-virtual-buffers t)
#+END_SRC

Let's fix a couple of navigation-related annoyances as well. By default, if no matches are found, ido will kick off a search for the file you might have meant. I found this annoying, so I disable it.

I also like being able to navigate into a directory and hit =.= to get dropped into dired in that directory.

And I want to invoke ido when my cursor is on a filename in the buffer text and have that file suggested as a completion. 

#+name: ido-settings-4
#+BEGIN_SRC emacs-lisp
(setq ido-auto-merge-work-directories-length -1
      ido-show-dot-for-dired t
      ido-use-filename-at-point 'guess)
#+END_SRC

I'm not sure why this is disabled by default, but let's enable it:

#+name: ido-settings-5
#+BEGIN_SRC emacs-lisp
(put 'ido-exit-minibuffer 'disabled nil)

#+END_SRC

*** ido-completing-read+

[[https://github.com/DarwinAwardWinner/ido-completing-read-plus][ido-completing-read+]] is an additional package that enables ido in even more places. Let's fire it up:

#+name:ido-ubiquitous
#+BEGIN_SRC emacs-lisp
;; use ido everywhere
(use-package ido-completing-read+)
(ido-ubiquitous-mode 1)

#+END_SRC

With this enabled, you'll be able to do things like hit =C-h f= (describe-function) and see a nice list of possible completions --- it'll even default suggest the function your cursor's sitting on.

*** ido-vertical

By default, ido lists possible completions horizontally, wrapping them if there are more completions than fit on the line. 

I prefer having completion candidates listed vertically and left-aligned --- they're much easier to scan that way.

We'll use [[https://github.com/gempesaw/ido-vertical-mode.el][the ido-vertical-mode package]] to set this up, and define keys for navigating up and down between candidates in the list.

#+name:ido-vertical
#+BEGIN_SRC emacs-lisp
;; stack my completions
(use-package ido-vertical-mode
             :init
             (progn (ido-vertical-mode 1)
                    (setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right)))

#+END_SRC

*** smex

[[file:img/smex.png]]

[[https://github.com/nonsequitur/smex][The smex package]] gives you all the autocompletion and fuzzy-matching goodness of ido, but for =M-x=, the infamous =execute-extended-command= function. 

Instead of hunting and scraping to find the function I'm looking for, I use smex + fuzzy matching and feel like an Emacs god.

#+name: smex-settings
#+BEGIN_SRC emacs-lisp
;;smexy smex
(use-package smex)
(global-set-key (kbd "M-x") 'smex)
(global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+END_SRC

I can get back to my original =M-x= functionality if I need it by using =C-c C-c M-x=.

#+name: smex-settings-old-mx
#+BEGIN_SRC emacs-lisp
;; This is your old M-x.
(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)

#+END_SRC
** Guide Key

#+ATTR_HTML: :width 600
[[file:img/guide-key-example.png]]

Guide-key lets you set up useful completion hints for certain key combinations. 

For example, I'm always forgetting certain org-mode shortcuts, so I've set up guide-key so that when I'm working in org, I can type =C-c= and wait a second to see a menu of all possible commands that start with =C-c=. 

It's especially useful when learning a new mode or new set of commands.

I can and should probably tweak this a little more and add additional key sequences to it, but for now this setup meets most of my needs.

#+name: guide-key
#+BEGIN_SRC emacs-lisp
;; gimme some hints
(use-package guide-key)
(defun guide-key/jcs-hook-function-for-org-mode ()
  (guide-key/add-local-guide-key-sequence "C-c")
  (guide-key/add-local-guide-key-sequence "C-c C-x"))
(add-hook 'org-mode-hook 'guide-key/jcs-hook-function-for-org-mode)
(setq guide-key/idle-delay 1)
(setq guide-key/popup-window-position 'bottom)
(guide-key-mode 1)
(diminish 'guide-key-mode)

#+END_SRC

** Popwin

[[https://github.com/m2ym/popwin-el][Popwin]] is installed as a dependency of guide-key, and it makes certain kinds of "pop-up" windows within your frame act slightly differently from regular windows --- you're able to dismiss them quickly by typing =0=, and provides some other useful features.

#+name: popwin
#+BEGIN_SRC emacs-lisp
;; put those hints in a nice pop-up window
(use-package popwin)
(defun popwin-bkr:update-window-reference ()
  (popwin:update-window-reference 'browse-kill-ring-original-window :safe t))
(add-hook 'popwin:after-popup-hook 'popwin-bkr:update-window-reference)
(push "*Kill Ring*" popwin:special-display-config)
(popwin-mode 1)

#+END_SRC
** Magit

[[https://magit.vc/][Magit is git made magical.]] 

It wraps git commands in a spiffy interface that's legitimately enjoyable to use. Which is good, because I use it pretty much every day.

#+ATTR_HTML: :width 600
[[file:img/magit.png]]

I don't use many customized setup options for magit yet. I may in the future.

#+name: coding-magit
#+BEGIN_SRC emacs-lisp
;; git on up
(use-package magit)
(setq magit-push-always-verify nil)

#+END_SRC


* Load custom settings

** Load separate settings file -- need to break this down
#+name: custom-settings
#+BEGIN_SRC emacs-lisp
;; Set up interface and editor options the way I like 'em:
(load-file (concat dotemacs-dir "lisp/settings.el"))

#+END_SRC


* Org-mode
:PROPERTIES:
:noweb-ref: Set up org-mode
:END:

** Load org-mode setup (still need to get this into separate org doc)

#+name: hacks-org-setup
#+BEGIN_SRC emacs-lisp
(load-file "~/.emacs.d/lisp/init-org-mode.el")

#+END_SRC
